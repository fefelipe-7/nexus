# Arquitetura Nexus

## Visão Geral

O Nexus segue uma arquitetura modular baseada em monorepo, separando claramente as responsabilidades entre camadas e domínios.

## Estrutura de Diretórios

### apps/
Aplicações front-end e interfaces do usuário

- **client/**: Aplicação React principal
  - **src/app/**: Configuração e bootstrap da aplicação
    - bootstrap/: Inicialização do app
    - navigation/: Configuração de rotas
    - lifecycle/: Hooks de ciclo de vida
  - **src/ui/**: Componentes de interface
    - components/: Componentes reutilizáveis
    - layouts/: Layouts de página
    - charts/: Componentes de visualização
    - themes/: Sistema de temas
  - **src/screens/**: Telas da aplicação
    - dashboard/: Painel principal
    - timeline/: Linha do tempo
    - domains/: Telas específicas de domínio
    - settings/: Configurações
  - **src/state/**: Gerenciamento de estado
    - stores/: Stores Zustand
    - selectors/: Seletores de estado
    - sync/: Sincronização de estado
  - **src/data/**: Camada de dados
    - local/: IndexedDB (Dexie)
    - cache/: Cache local
    - adapters/: Adaptadores para APIs externas
  - **src/ai/**: Integração com IA
    - prompts/: Templates de prompts
    - client/: Cliente de IA
  - **src/config/**: Configurações

### packages/
Pacotes compartilhados e lógica de negócio

- **core/**: Lógica de domínio e casos de uso
  - **domain/**: Entidades e regras de negócio
    - entities/: Entidades de domínio (State, Action, Event, Goal, etc)
    - value-objects/: Objetos de valor
    - aggregates/: Agregados
    - rules/: Regras de negócio
    - boundaries/: Limites de contexto
  - **use-cases/**: Casos de uso da aplicação
    - capture/: Captura de dados
    - update/: Atualização de dados
    - relate/: Relacionamento entre entidades
    - aggregate/: Agregação de dados
    - summarize/: Sumarização
  - **ports/**: Interfaces (Hexagonal Architecture)
    - repositories/: Interfaces de repositórios
    - ai/: Interfaces de IA
    - storage/: Interfaces de armazenamento
    - sync/: Interfaces de sincronização

- **shared/**: Utilitários e tipos compartilhados
  - utils/: Funções utilitárias
  - types/: Tipos TypeScript compartilhados
  - constants/: Constantes da aplicação
  - errors/: Classes de erro customizadas

- **data-model/**: Modelo de dados
  - schemas/: Schemas de validação
  - migrations/: Migrações de banco
  - serialization/: Serialização de dados
  - versioning/: Versionamento de dados

- **sync-engine/**: Motor de sincronização
  - diff/: Detecção de diferenças
  - merge/: Merge de dados
  - conflict-resolution/: Resolução de conflitos
  - queues/: Filas de sincronização

- **analytics/**: Análise de dados
  - time-series/: Séries temporais
  - aggregations/: Agregações
  - metrics/: Métricas
  - trends/: Análise de tendências

- **ai-core/**: Núcleo de IA
  - interpretation/: Interpretação de dados
  - summarization/: Sumarização
  - embeddings/: Embeddings
  - reasoning/: Raciocínio
  - memory/: Memória de contexto
  - explainability/: Explicabilidade

- **privacy/**: Privacidade e conformidade
  - retention/: Retenção de dados
  - anonymization/: Anonimização
  - consent/: Gerenciamento de consentimento
  - deletion/: Deleção de dados

### services/
Serviços backend (futuro)

- **api/**: API REST/GraphQL
- **sync-service/**: Serviço de sincronização
- **ai-service/**: Serviço de IA
- **scheduler/**: Agendador de tarefas
- **webhooks/**: Webhooks

### infra/
Infraestrutura e configuração

- **env/**: Variáveis de ambiente
- **database/**: Schemas e seeds do banco
- **storage/**: Configuração de armazenamento
- **queues/**: Configuração de filas
- **monitoring/**: Monitoramento
- **deployment/**: Scripts de deploy

## Princípios Arquiteturais

### 1. Separação de Responsabilidades
- UI separada da lógica de negócio
- Lógica de negócio independente de frameworks
- Dados isolados em camada própria

### 2. Modularidade
- Pacotes independentes e reutilizáveis
- Dependências explícitas
- Baixo acoplamento, alta coesão

### 3. Domain-Driven Design
- Entidades de domínio bem definidas
- Casos de uso explícitos
- Linguagem ubíqua

### 4. Hexagonal Architecture (Ports & Adapters)
- Core isolado de detalhes de implementação
- Interfaces (ports) definem contratos
- Adaptadores implementam integrações

### 5. Local-First
- Dados locais como fonte primária
- Sincronização eventual
- Funcionamento offline

### 6. Privacy by Design
- Dados do usuário permanecem locais
- Criptografia quando necessário
- Controle total do usuário

## Fluxo de Dados

1. **UI Layer** → Componentes React
2. **State Layer** → Zustand stores
3. **Use Cases Layer** → Lógica de negócio
4. **Domain Layer** → Entidades e regras
5. **Data Layer** → IndexedDB/Supabase

## Tecnologias

- **Frontend**: React 18, TypeScript, Vite
- **Styling**: Tailwind CSS, shadcn/ui
- **State**: Zustand
- **Data**: Dexie (IndexedDB), Supabase
- **Build**: Vite, npm workspaces
- **Types**: TypeScript strict mode

## Próximos Passos

1. Implementar casos de uso em packages/core
2. Criar adaptadores para Supabase
3. Implementar sync-engine
4. Adicionar analytics
5. Integrar IA
